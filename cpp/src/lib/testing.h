#ifndef AOC_TESTING_H
#define AOC_TESTING_H

#include <csignal>
#include <sstream>
#include <string>
#include <vector>

namespace aoc {

// TestError represents a test failure.
class TestError : std::exception {
  std::string msg_;
  std::string file_;
  int line_;

 public:
  TestError(const std::string msg, const std::string file = "",
            const int line = 0);

  template <typename T>
  TestError(const std::string expr, const std::string op,
            const std::string expect, const T& actual, const std::string file,
            const int line)
      : file_(file), line_(line) {
    std::stringstream ss;
    ss << "Expression evaluates to false: (" << expr << " " << op << " "
       << expect << ")\n    (" << expr << ") â†’ " << actual;
    msg_ = ss.str();
  }

  const std::string msg() const;
  const std::string file() const;
  int line() const;

  // Implements std::exception.
  char* what();
};

// Converts any thrown exception to a TestError.
//
// Internal implementation detail.
#define WRAP_(expr)                                                           \
  {                                                                           \
    try {                                                                     \
      expr;                                                                   \
    } catch (aoc::TestError e) {                                              \
      throw;                                                                  \
    } catch (std::exception e) {                                              \
      throw aoc::TestError("Uncaught exception: " + std::string(e.what()),    \
                           __FILE__, __LINE__);                               \
    } catch (char const* e) {                                                 \
      throw aoc::TestError("Uncaught exception: " + std::string(e), __FILE__, \
                           __LINE__);                                         \
    } catch (...) {                                                           \
      throw aoc::TestError("Uncaught exception.", __FILE__, __LINE__);        \
    }                                                                         \
  }

// Base class for all user-defined test cases.
class BaseTest {
 protected:
  std::vector<TestError> errv_;

 public:
  virtual ~BaseTest() = default;

  // Returns the name of the test case.
  virtual std::string name() const = 0;

  // Returns the name of the test suite.
  virtual std::string suite() const = 0;

  // Returns the name of the file where the test is defined.
  virtual std::string file() const = 0;

  // Returns the line in the file where the test is defined.
  virtual int line() const = 0;

  // Runs the test and converts any exceptions to TestErrors.
  virtual void run() = 0;

  // // Runs the user-defined implementation of the test body.
  // virtual void run() = 0;

  // Returns a list of any errors generated by the test.
  const std::vector<TestError> errv() const;

  // Returns the tests fully qualified name.
  std::string str() const;

  // Returns true if the test passed its last run.
  operator bool() const;

  // Returns true if the test's fully qualified name is less than the other's.
  bool operator<(const BaseTest& rhs) const;

  friend std::ostream& operator<<(std::ostream& os, BaseTest& t);

 protected:
  // Sets the handler for common signals.
  void signal(void (*handler)(int));
};

// Base class of all user-defined test constructors.
struct BaseTestFactory {
  virtual BaseTest* make() const = 0;
};

// Constructs a user-defined test case.
template <class T>
struct TestFactory : public BaseTestFactory {
  BaseTest* make() const override { return new T(); }
};

// Manages and runs test suites and cases.
struct TestRunner {
  // Registers the contstructor for a new test case.
  //
  // Internal implementation detail.
  static int register_ctor(const BaseTestFactory* factory);

  // Constructs and returns a new instance of each user-defined test case.
  static std::vector<BaseTest*> make();

  // Runs all test cases and returns the number of failed cases.
  static int run();
};

// Returns a classname for the given suite and test case.
#define TEST_CLASS_NAME(suite_name, test_name) suite_name##test_name##Test

// Generates a test class declaration and registers it with the test runner.
#define TEST(suite_name, test_name)                                        \
  class TEST_CLASS_NAME(suite_name, test_name) : public aoc::BaseTest {    \
   private:                                                                \
    static const int id_;                                                  \
    std::string name() const override { return #test_name; }               \
    std::string suite() const override { return #suite_name; }             \
    std::string file() const override { return __FILE__; }                 \
    int line() const override { return __LINE__; }                         \
                                                                           \
    static void signal_handler(const int sig) {                            \
      std::stringstream ss;                                                \
      ss << "Caught signal: " << sig;                                      \
      throw aoc::TestError(ss.str(), __FILE__, __LINE__);                  \
    }                                                                      \
                                                                           \
    void run() override {                                                  \
      signal(TEST_CLASS_NAME(suite_name, test_name)::signal_handler);      \
      try {                                                                \
        WRAP_(test_body());                                                \
      } catch (aoc::TestError e) {                                         \
        errv_.push_back(e);                                                \
      }                                                                    \
      signal(SIG_DFL);                                                     \
    }                                                                      \
                                                                           \
    void test_body();                                                      \
  };                                                                       \
                                                                           \
  const int TEST_CLASS_NAME(suite_name, test_name)::id_ =                  \
      aoc::TestRunner::register_ctor(                                      \
          new aoc::TestFactory<TEST_CLASS_NAME(suite_name, test_name)>()); \
                                                                           \
  void TEST_CLASS_NAME(suite_name, test_name)::test_body()

#define EXPECT(expr, op, expect)                                             \
  {                                                                          \
    WRAP_(auto actual = expr; if (!(actual op expect)) throw aoc::TestError( \
              #expr, #op, #expect, actual, __FILE__, __LINE__));             \
  }

#define EXPECT_TRUE(expr) EXPECT(expr, ==, 1)
#define EXPECT_FALSE(expr) EXPECT(expr, ==, 0)
#define EXPECT_EQ(a, b) EXPECT(a, ==, b)
#define EXPECT_NE(a, b) EXPECT(a, !=, b)
#define EXPECT_LT(a, b) EXPECT(a, <, b)
#define EXPECT_GT(a, b) EXPECT(a, >, b)
#define EXPECT_LE(a, b) EXPECT(a, <=, b)
#define EXPECT_GE(a, b) EXPECT(a, >=, b)

}  // namespace aoc

#endif  // AOC_TESTING_H